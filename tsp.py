# -*- coding: utf-8 -*-
"""TSP.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13cLpJDT1DX-xbNiTjN_2iBR4CcW0zSQ9
"""

from itertools import permutations

# Define a function to calculate the total distance of a given route
def calculate_total_distance(route, distance_matrix):
   total_distance = 0
   n = len(route)
   # Add up the distances for each pair of cities in the route
   for i in range(n - 1):
      total_distance += distance_matrix[route[i]][route[i + 1]]
      # Add the distance to return to the starting city
      total_distance += distance_matrix[route[- 1]][route[0]]
      return total_distance

# Brute-force TSP
def tsp_brute_force(distance_matrix):
  n = len(distance_matrix)
  cities = list(range(n))
  min_distance = float('inf')
  best_route = None

# Generate all possible permutations of cities (excluding the starting city)
  for perm in permutations(cities[1:]):
      # Add the starting city (0) at the beginning and end of the permutation
      route = [0] + list(perm)
      print(f"Checking route: {route}")
      total_distance = calculate_total_distance(route, distance_matrix)
      print(f"Total distance: {total_distance}")
      print("")

      # Update the best route if a shorter route is found
      if total_distance < min_distance:
        min_distance = total_distance
        best_route = route
        print(f"New best route: {best_route} with distance {min_distance}")

  return best_route, min_distance

# Example distance matrix (A, B, C, D)
distance_matrix = [
[0, 10, 15, 20], # Distances from city A
[10, 0, 35, 25], # Distances from city B
[15, 35, 0, 30], # Distances from city C
[20, 25, 30, 0]  # Distances from city D
]

# Solve the TSP
best_route, min_distance = tsp_brute_force(distance_matrix)

# Print the results
print("\nOptimal route:", best_route)
print("Minimum distance:", min_distance)